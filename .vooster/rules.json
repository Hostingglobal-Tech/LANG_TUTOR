{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 개요\n초등학교 1‧2학년 아이들이 다양한 언어의 기본 인사말(예: “안녕하세요”, “고맙습니다”)을 쉽고 즐겁게 학습할 수 있도록 지원하는 웹 기반 학습 서비스. 간단한 클릭-중심 UI와 귀여운 일러스트, 원어민 음성으로 학습 효과를 극대화한다. 내부 교육용이므로 로그인·DB 없이 정적 배포 형태로 제공된다.\n\n## 2. 문제 정의\n- 아이들이 여러 언어의 인사말을 배울 수 있는 무료·간단·안전한 온라인 자원이 부족\n- 기존 자료는 글 위주라 발음 습득이 어려움\n- 교사‧가족이 짧은 시간에 아이와 함께 사용할 수 있는 직관적 서비스 필요\n\n## 3. 목표 및 목적\n- 1차 목표: 4주 내 다국어 인사말 10개 이상, 8개 언어 제공 웹 서비스 출시\n- 부가 목표:\n  - 시청각 요소로 몰입도 향상\n  - 무설치·무계정 즉시 사용\n  - 접근성(색맹·저시력) 지침 준수\n- 성공 지표:\n  - 1회 세션 평균 체류 시간 ≥ 3분\n  - 음성 재생 클릭률 ≥ 70%\n  - 사용자 만족도(교사 설문) ≥ 4/5\n\n## 4. 대상 사용자\n### 주요 사용자\n- 연령: 초1‧2, 7~9세\n- 특성: 짧은 집중 시간, 시각적 요소 선호, 마우스·터치 사용 가능\n- 니즈: 재미있고 빠른 학습, 발음 모방\n\n### 보조 사용자\n- 교사/부모/조부모: 수업·가정 학습 보조\n- 콘텐츠 기획자: 내부 교육자료 제작 참고\n\n## 5. 사용자 스토리\n- 초1 학생으로서, 버튼을 눌러 외국어 인사말을 들어보고 따라 하고 싶다.\n- 부모로서, 5분 안에 아이와 함께 여러 언어 인사를 체험해 보고 싶다.\n- 교사로서, 수업 도입 10분 동안 간단히 사용할 수 있는 자료를 원한다.\n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 언어 선택\n   - 화면 상단 드롭다운 또는 플래그 아이콘 리스트\n   - 수락 기준: 언어 클릭 시 해당 언어 카드 목록 갱신\n\n2. 인사말 카드\n   - 카드 구성: 한글 뜻, 원문 표기, 음성 아이콘, 일러스트\n   - 수락 기준: 클릭 시 300ms 이내 원어민 음성 재생, 그림 alt 텍스트 제공\n\n3. 발음 연습 모드\n   - 음성 재생 후 3초 카운트다운, 사용자가 따라 말함\n   - 수락 기준: 마이크 권한 요청, 녹음 오프라인 저장(X), 시각화 진행 바\n\n4. 퀴즈 모드 (MVP+2주)\n   - 한국어 뜻 → 언어 선택, 또는 음성 듣고 언어 맞히기\n   - 수락 기준: 5문제 완료 후 점수 및 칭찬 애니메이션\n\n### 보조 기능\n- 다크모드 자동 전환\n- 언어별 PDF/PNG 프린트용 워크시트 다운로드\n- 설정 페이지: 글꼴 크기, 배경음 on/off\n\n## 7. 비기능 요구사항\n- 성능: 최초 로드 ≤ 2초(Lighthouse 90점 이상)\n- 보안: HTTPS, 외부 API 호출 시 CORS 허용 도메인 제한\n- 사용성: WCAG 2.1 AA, 키보드 탐색 완전 지원\n- 확장성: 새 언어 추가 시 코드 변경 최소화(JSON 추가)\n- 호환성: 크롬·사파리·엣지 최신 2버전 / iPadOS, Android Chrome\n\n## 8. 기술 고려사항\n- 아키텍처: Next.js + Static Generation; Netlify/Vercel 배포\n- 데이터: greetings.json 정적 파일(언어, 한국어, 로마자, 음성 URL, 일러스트 경로)\n- 통합: ElevenLabs API로 음성 생성, 생성된 파일은 CDN에 사전 업로드. API키 필요\n- 의존성: react-howler(오디오), styled-components, i18next\n\n## 9. 성공 지표\n- 주간 활성 사용자(WAU) 30명 이상(내부 교실 기준)\n- 1세션당 카드 평균 8개 이상 조회\n- Lighthouse 접근성 점수 ≥ 95\n- 오류 로그(Sentry) 0.1% 미만\n\n## 10. 일정 및 마일스톤\n- 0주: 기획 확정, 디자인 시스템 스케치\n- 1주: Next.js 프로젝트 셋업, JSON 스키마 확정\n- 2주: 언어 선택 · 카드 컴포넌트 완성\n- 3주: 발음 연습 모드 및 접근성 QA\n- 4주: MVP 릴리스, 내부 테스트\n- 6주: 퀴즈 모드, 다크모드, 최종 배포\n\n## 11. 위험요소 및 대응\n- TTS 비용 증가 → 오픈소스 음성 추가 및 캐싱\n- 아이 집중도 저하 → 짧은 애니메이션, 즉각 피드백\n- 브라우저 마이크 권한 거부 → 녹음 필수 아님, 건너뛰기 옵션 안내\n\n## 12. 향후 계획\n- 수어(한국어/국제) 영상 삽입\n- AR 카메라 필터(입 모양 가이드)\n- 오프라인 USB 패키지(학교 네트워크 제한 대비)\n\n",
      "writedAt": "2025-07-13T11:13:42.053Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  초등학교 1·2학년 대상의 정적 웹 기반 다국어 인사말 학습 서비스. Next.js의 Static Generation을 활용하여 로그인·DB 없이 Netlify/Vercel에 무설치 배포. JSON 데이터 기반으로 간단한 클릭 UI, 원어민 음성, 일러스트를 제공.\n\n- **핵심 기술 스택**  \n  Next.js, React, Styled-Components, i18next, react-howler, Netlify/Vercel, greetings.json, CDN(음성·일러스트)\n\n- **주요 기술 목표**  \n  • 최초 로드 ≤ 2초(Lighthouse ≥ 90)  \n  • WCAG 2.1 AA 준수(접근성 ≥ 95점)  \n  • 음성 재생 클릭률 ≥ 70% 충족  \n  • 세션 체류 시간 ≥ 3분 달성\n\n- **핵심 기술 가정**  \n  • 모든 콘텐츠(음성·이미지)는 빌드 단계에 CDN에 업로드  \n  • 클라이언트 측 API 호출 최소화(정적 JSON 사용)  \n  • 마이크 녹음 기능은 브라우저 Web API로 충분\n\n## 2. Tech Stack\n\n| Category           | Technology / Library        | Reasoning                                                      |\n| ------------------ | --------------------------- | -------------------------------------------------------------- |\n| 프레임워크         | Next.js                     | Static Generation, SEO, 빌드 타임 데이터 연동 간편              |\n| UI 라이브러리      | React                       | 컴포넌트 기반 구조, 학습 커뮤니티 활발                          |\n| 스타일링           | styled-components           | CSS-in-JS, 테마(dark/light) 관리 용이                           |\n| 다국어 지원        | i18next                     | JSON 기반 언어 리소스, 코드 변경 없이 언어 확장 가능            |\n| 오디오 재생        | react-howler                | 간단한 오디오 API, preload/playing 제어 가능                   |\n| 배포               | Netlify / Vercel            | 무서버리스 정적 호스팅, CI/CD 자동화                           |\n| 데이터 저장        | greetings.json              | 정적 JSON, 빌드 시점에 로드, 언어 추가 시 파일만 갱신           |\n| 일러스트·음성 CDN  | AWS S3 + CloudFront 등      | 글로벌 캐싱, 빠른 전송 보장                                     |\n| 접근성             | axe-core (개발 도구)        | WCAG 검사 자동화                                              |\n| 빌드 도구           | Esbuild (내장)              | 빠른 번들링                                                    |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- Frontend (Next.js)  \n  • Static Generation 및 Client-Side Hydration  \n  • 페이지 라우팅 (언어 선택, 카드, 연습, 퀴즈, 설정)\n- Data Layer  \n  • greetings.json (언어·인사말 메타데이터)  \n  • CDN 호스팅 음성·일러스트 파일\n- UI Components  \n  • 언어 선택 드롭다운/플래그  \n  • 인사말 카드, 연습 모드, 퀴즈 모듈, 설정 패널\n- 접근성 & 테마 관리  \n  • WCAG 준수 스타일, dark/light 자동 전환\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    A[User Browser] --> B[Next.js Static Page]\n    B --> C[greetings.json]\n    B --> D[CDN(Audio/Illustration)]\n    B --> E[i18next 번역 리소스]\n    A --> F[Web Audio API (마이크)]\n```\n\n- 사용자가 브라우저에서 Next.js로 빌드된 페이지 요청  \n- 클라이언트에서 greetings.json·i18next 로드 후 렌더링  \n- 음성·일러스트는 CDN에서 직접 스트리밍  \n- 마이크 녹음은 Web Audio API로 처리\n\n### Code Organization & Convention\n\n**도메인 기반 구조**  \n- 언어 선택, 카드, 연습 모드, 퀴즈, 설정 등 기능별 도메인 분리  \n- 프레젠테이션·비즈니스 로직·데이터 접근 계층 분리\n\n**폴더 구조 예시**\n```\n/\n├── public/\n│   ├── locale/              # i18next JSON 리소스\n│   ├── audio/               # CDN 동기화 폴더\n│   └── images/              # 일러스트\n├── src/\n│   ├── components/          # 재사용 UI 컴포넌트\n│   │   ├── LanguagePicker/\n│   │   ├── GreetingCard/\n│   │   └── ...\n│   ├── domains/             # 도메인별 기능 모듈\n│   │   ├── practice/        # 발음 연습 모드\n│   │   ├── quiz/            # 퀴즈 모드\n│   │   └── settings/\n│   ├── pages/               # Next.js 페이지\n│   ├── lib/                 # 데이터 로딩, 유틸리티\n│   ├── styles/              # 글로벌 스타일, 테마\n│   └── types/               # 공통 타입 정의\n├── greetings.json           # 정적 데이터\n└── next.config.js\n```\n\n### Data Flow & Communication Patterns\n- **클라이언트-서버 통신**: 빌드 시점 정적 로드, 클라이언트에서 fetch 없이 import  \n- **데이터베이스 상호작용**: 없음(정적 JSON)  \n- **외부 서비스 통합**: 음성 생성은 빌드 파이프라인에서 One-time 처리 (ElevenLabs)  \n- **실시간 통신**: Web Audio API를 통한 마이크 입력 → 로컬 메모리 처리  \n- **데이터 동기화**: 도메인별 JSON 변경 시 빌드 재실행\n\n## 4. Performance & Optimization Strategy\n- 코드 스플리팅 및 SSR/SSG 활용으로 초기 번들 크기 최소화  \n- 이미지·오디오 최적화(압축, CDNs) 및 preload 설정  \n- Lighthouse CI 도입해 지속적 성능 모니터링  \n- 사용자 인터랙션 중심 지연 로딩(lazy load) 적용  \n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation)  \n- **Core Infrastructure**: Next.js 프로젝트 초기화, CI/CD 설정  \n- **Essential Features**: 언어 선택, 인사말 카드, 원어민 재생, 접근성 기본  \n- **Basic Security**: HTTPS 설정, CORS 제한  \n- **Development Setup**: ESLint, Prettier, Lighthouse CI  \n- **Timeline**: 4주\n\n### Phase 2: Feature Enhancement  \n- **Advanced Features**: 발음 연습 모드, 다크모드, 워크시트 다운로드  \n- **Performance Optimization**: 코드 스플리팅, 이미지·오디오 캐싱  \n- **Enhanced Security**: CSP 적용, 외부 스크립트 제한  \n- **Monitoring Implementation**: Sentry 통합  \n- **Timeline**: +2주\n\n### Phase 3: Scaling & Optimization  \n- **Scalability Implementation**: CDN 글로벌 분산, 빌드 파이프라인 최적화  \n- **Advanced Integrations**: 오프라인 PWA, S3 Pre-signed URL  \n- **Enterprise Features**: 통계 대시보드(내부 사용)  \n- **Compliance & Auditing**: WCAG 2.1 재검증, 보안 감사  \n- **Timeline**: +4주\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **Technology Risks**: Static JSON 확장 한계 → 모듈화 구조, 코드 자동화  \n- **Performance Risks**: 초기 로드 지연 → 코드 스플리팅, CDN 활용  \n- **Security Risks**: XSS, CORS 오남용 → CSP, 엄격한 CORS 정책  \n- **Integration Risks**: TTS 서비스 장애 → 로컬 캐싱, 오픈소스 대체 TTS\n\n### Project Delivery Risks\n- **Timeline Risks**: 디자인 피드백 지연 → 디자인 시스템 조기 확정  \n- **Resource Risks**: 프론트엔드 전문 인력 부족 → 기술 스터디, 가이드 제공  \n- **Quality Risks**: 테스트 커버리지 미비 → 유닛·E2E 테스트 최소 80% 확보  \n- **Deployment Risks**: 호스팅 환경 설정 오류 → 스테이징 환경 사전 검증  \n- **Contingency Plans**:  \n  • 음성 미리 녹음 파일 사용  \n  • 정적 HTML 빌드로 롤백 가능\n\n---\n\n**END OF DOCUMENT**",
      "writedAt": "2025-07-13T11:13:42.055Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-13T11:13:42.055Z"
    },
    {
      "type": "tdd",
      "content": "\n# TDD Process Guidelines - Cursor Rules\n\n## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification\n\n**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**\n\n## Core Cycle: Red → Green → Refactor\n\n### 1. RED Phase\n- Write a failing test FIRST\n- Test the simplest scenario\n- Verify test fails for the right reason\n- One test at a time\n\n### 2. GREEN Phase  \n- Write MINIMAL code to pass\n- \"Fake it till you make it\" is OK\n\n- YAGNI principle\n\n### 3. REFACTOR Phase\n- Remove duplication\n- Improve naming\n- Simplify structure\n- Keep tests passing\n\n## Test Quality: FIRST Principles\n- **Fast**: Milliseconds, not seconds\n- **Independent**: No shared state\n- **Repeatable**: Same result every time\n- **Self-validating**: Pass/fail, no manual checks\n- **Timely**: Written just before code\n\n## Test Structure: AAA Pattern\n```\n// Arrange\nSet up test data and dependencies\n\n// Act\nExecute the function/method\n\n// Assert\nVerify expected outcome\n```\n\n## Implementation Flow\n1. **List scenarios** before coding\n2. **Pick one scenario** → Write test\n3. **Run test** → See it fail (Red)\n4. **Implement** → Make it pass (Green)\n5. **Refactor** → Clean up (Still Green)\n6. **Commit** → Small, frequent commits\n7. **Repeat** → Next scenario\n\n## Test Pyramid Strategy\n- **Unit Tests** (70%): Fast, isolated, numerous\n- **Integration Tests** (20%): Module boundaries\n- **Acceptance Tests** (10%): User scenarios\n\n## Outside-In vs Inside-Out\n- **Outside-In**: Start with user-facing test → Mock internals → Implement details\n- **Inside-Out**: Start with core logic → Build outward → Integrate components\n\n## Common Anti-patterns to Avoid\n- Testing implementation details\n- Fragile tests tied to internals  \n- Missing assertions\n- Slow, environment-dependent tests\n- Ignored failing tests\n\n## When Tests Fail\n1. **Identify**: Regression, flaky test, or spec change?\n2. **Isolate**: Narrow down the cause\n3. **Fix**: Code bug or test bug\n4. **Learn**: Add missing test cases\n\n## Team Practices\n- CI/CD integration mandatory\n- No merge without tests\n- Test code = Production code quality\n- Pair programming for complex tests\n- Regular test refactoring\n\n## Pragmatic Exceptions\n- UI/Graphics: Manual + snapshot tests\n- Performance: Benchmark suites\n- Exploratory: Spike then test\n- Legacy: Test on change\n\n## Remember\n- Tests are living documentation\n- Test behavior, not implementation\n- Small steps, fast feedback\n- When in doubt, write a test\n",
      "writedAt": "2025-07-13T11:13:42.055Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-13T11:13:42.055Z"
    }
  ]
}